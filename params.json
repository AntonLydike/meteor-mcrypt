{
  "name": "Meteor-mcrypt",
  "tagline": "A meteor package to encrypt users data with user-specific keys for later use!",
  "body": "# Meteor mcrypt\r\n### Table of contents:\r\n  1. [What is this](#what-is-this)\r\n  2. [API](#api)\r\n      1. [configure(settings)](#configuresettings)\r\n      2. [encrypt(cleartext, userId, [salt, [context]])](#encryptcleartext-userid-salt-context)\r\n      3. [decrypt(ciphertext, userId, [salt, [context]])](#decryptciphertext-userid-salt-context)\r\n      4. [generateSalt([length])](#generatesaltlength)\r\n      5. [McryptError(code, reason, [data])](#mcrypterrorcode-reason-data)\r\n  3. [Usage](#usage)\r\n  4. [Tests](#tests)\r\n  5. [License](#license)\r\n\r\n### What is this?\r\nEncrypt important data in your DB for later use. This uses the [Node.js crypto][4] library.\r\n\r\nEach users data will be encrypted with a seperate key to make decryption harder in case of a data breach. The user-specific key (user-key) is derived from the application-key (app-key) plus a user-specific salt per PBKDF2.\r\n\r\n**IMPORTANT:** This should NOT be used to encrypt passwords for your own login system. Often times, a [simple hashing algorithm][5] will serve you better. Especially in terms of security!\r\n\r\nTo install the package, run: `meteor add antonly:mcrypt`.\r\n\r\n### API\r\nImport it like this: `import mcrypt from 'meteor/antonly:mcrypt'`.\r\n\r\n#### configure(settings)\r\nConfigure the package to exactly fit your needs\r\n\r\n**default settings:**\r\n````js\r\nmcrypt.configure({\r\n  getUserSalt(uid, context) {\r\n    // example method for getting the salt from the user db\r\n    const usr = Meteor.users.findOne(uid);\r\n\r\n    if (!usr || !usr.secret_key_storage || !usr.secret_key_storage.salt) {\r\n      throw new mcrypt.Error(\r\n        'no-salt-given', \r\n        `Salt for user with id '${userId}' was not found in the db.`, \r\n        {userId, context}\r\n      );\r\n    }\r\n\r\n    return usr.secret_key_storage.salt;\r\n  },\r\n  getAppKey(context)  {\r\n    return Meteor.settings.ENCRYPT_PASSW_ENCRYPTION_KEY;\r\n  },\r\n  getUserKeyLen(context)  {\r\n    return Meteor.settings.ENCRYPT_PASSW_USER_KEY_LENGTH;\r\n  },\r\n  getRounds(context)  {\r\n    return Meteor.settings.ENCRYPT_PBKDF2_ROUNDS;\r\n  },\r\n  getDigest(context)  {\r\n    return Meteor.settings.ENCRYPT_PBKDF2_DIGEST;\r\n  },\r\n  getAlgorithm(context)  {\r\n    return Meteor.settings.ENCRYPT_PASSW_ALGORITHM;\r\n  },\r\n  throwDecryptError(context) {\r\n    return Meteor.settings.ENCRYPT_THROW_DECRYPT_ERR;\r\n  },\r\n  getSaltLen()  {\r\n    return Meteor.settings.ENCRYPT_PASSW_SALT_LENGTH;\r\n  }\r\n})\r\n````\r\n  1. `getUserSalt(uid, context)` a function to get the users salt. (in this example it is taken from the Meteor.users db)\r\n  2. `getAppKey(context)` this function return the app-key. It is recommended that you don't change the following functions but rather add the following lines to your [settings.json][6]. All the following functions are just wrappers for the `Meteor.settings` variables.\r\n\r\nThe `context` wil be passed along from a `decrypt` or `encrypt` call to all settings methods (except `getSaltLen`) and can help you customize your values to your specifc needs.\r\n\r\n**settings.json:**\r\n````JSON\r\n{\r\n  \"ENCRYPT_PASSW_ENCRYPTION_KEY\": \"*some long encryption key*\",\r\n  \"ENCRYPT_PASSW_SALT_LENGTH\": 32,\r\n  \"ENCRYPT_PASSW_USER_KEY_LENGTH\": 32,\r\n  \"ENCRYPT_PBKDF2_ROUNDS\": 100,\r\n  \"ENCRYPT_PBKDF2_DIGEST\": \"sha512\",\r\n  \"ENCRYPT_PASSW_ALGORITHM\": \"aes-256-ctr\",\r\n  \"ENCRYPT_THROW_DECRYPT_ERR\": false\r\n}\r\n````\r\nIn order to be able to use these settings in your meteor app, you will have to add the settings parameter to your `meteor` command: `meteor --settings development.json`\r\n\r\n**What each entry does:**\r\n  1. `ENCRYPT_PASSW_ENCRYPTION_KEY` Your secret key (aka. app-key). This key should be impossible to guess, so chose a big one.\r\n  2. `ENCRYPT_PASSW_SALT_LENGTH` The length (in bytes) of a standard 'salt' to derive the user-specific key\r\n  3. `ENCRYPT_PASSW_USER_KEY_LENGTH` The length (in bytes) of the key, derived from PBKDF2(app-key, salt) that is used to encrypt the data\r\n  4. `ENCRYPT_PBKDF2_ROUNDS` and `ENCRYPT_PBKDF2_DIGEST` correspond to their PBKDF2 parameters (more [here][2])\r\n  5. `ENCRYPT_PASSW_ALGORITHM` is the algorithm used to encrypt the data (the algorithm field of [crypto.createCipher][3])\r\n  6. `ENCRYPT_THROW_DECRYPT_ERR` Some algorithms will throw errors when trying to decipher with the wron key. If this is set to false, the error will be catched and an McryptError will be returned instead.\r\n\r\nSidenote: Of course you have to use your own parameters. These are just the development settings. You will have to choose your own parameters, depending on the importance of your data. (PBKDF2_ROUNDS should be chosen to fit your host system. I've read [somewhere][1] that a hash should take **at least** 241 milliseconds)\r\n\r\nIf you want to set your own values, `mcrypt.configure` expects an object with **functions or values** to replace the standard ones:\r\n````js\r\nmcrypt.configure({\r\n  getUserSalt(uid, context) {\r\n    let db = AdminsDB;\r\n    \r\n    if (context == 'clients') {\r\n      db = ClientsDB;\r\n    }\r\n    \r\n    return db.find(uid).secret.salt;\r\n  },\r\n  getRounds: 10e9, // 10000000000\r\n  getSaltLen: 64\r\n})\r\n````\r\n(notice how you can pass functions or values)\r\n\r\n#### encrypt(cleartext, userId, [salt, [context]])\r\nEncrypts the given cleartext. \r\n  * `cleartext` The utf-8 string to encrypt\r\n  * `userId` the ID of the user who's salt will be used\r\n  * `salt` can be passed instead of `userId` if you already got it, or just generated it. If the salt is omitted or false, the result of `getUserSalt(userId, context)` will be used as salt. The salt is used to derive the user-key from the app-key\r\n  * `context` is passed along to the `getUserSalt(userId, context)` function in the case that no salt is provided directly\r\n  \r\n**examples**\r\n````js\r\nimport mcrypt from 'meteor/antonly:mcrypt';\r\n\r\nconst cleartext   = 'Cleartext 1',\r\n      salt        = 'Just some simple salt';\r\n\r\n// encrypt with salt from DB\r\nconst ciphertext  = mcrypt.encrypt(cleartext, 1); \r\n// this will use the salt from user with the ID 1\r\n\r\n// encrypt with known salt\r\nconst ciphertext2 = mcrypt.encrypt(cleartext, 0, salt); \r\n// the userId can be set to any arbitrary value because the salt is provided\r\n````\r\n\r\n#### decrypt(ciphertext, userId, [salt, [context]])\r\nDecrypts given ciphertext.\r\n  * `ciphertext` the text to decrypt\r\n  * `userId` same thing as before, either you specify a userId or a salt\r\n  * `salt` and `context` see encrypt \r\n\r\nThis can return a `bad-decrypt` error when `ENCRYPT_THROW_DECRYPT_ERR` is set to true. The error will look like this:\r\n````JS\r\nMcryptError {\r\n  _isError: true,\r\n  code: 'bad-decrypt',\r\n  reason: 'The ciphertext couldn\\'t be decrypted with the given key',\r\n  data: { \r\n    ciphertext: '2d27113bad83553254cd8a604282814e274ee4b08ccf57940e583f01a364b742',\r\n    salt: 'u/QOClVMrCOhESVa/pz0q6/plwCPVynoPMegKW3ArWw=',\r\n    userId: 'B',\r\n    context: { },\r\n    error: [Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt] \r\n  } \r\n}\r\n````\r\n`data.error` contains the catched error.\r\n\r\n#### generateSalt([length])\r\nGenerates a random salt using `crypto.randomBytes`. If you don't specify a length (in bytes) it will use the result of `getSaltLen()`.\r\n\r\n#### McryptError(code, reason, [data])\r\nAn error object. It has the following fields:\r\n  * `code` The error code (for example `'no-salt-given'`)\r\n  * `reason` a more in-depth explanation of what went wrong\r\n  * `data` (optional) Additional data for debugging or error handling / logging\r\n\r\n**example from the standard `getUserSalt` method:**\r\n````js\r\nthrow new mcrypt.Error(\r\n  'no-salt-given', \r\n  `Salt for user with id ${userId} was not found in the db.`, \r\n  {userId, context}\r\n);\r\n````\r\nThe error object will look something like this:\r\n````js\r\nMcryptError {\r\n  _isError: true,\r\n  code: 'no-salt-given',\r\n  reason: 'Salt for user with id 1 was not found in the db.',\r\n  data: { userId: 1, context: {} } \r\n}\r\n````\r\nIt also has a custom `toString` method, wich will return `[McryptError this.code]`. In this case it would be `[McryptError no-salt-given]`.\r\n\r\n\r\n### usage\r\nThis is the `mcrypt-tests.js` code modified slightly.\r\n\r\n````js\r\nimport mcrypt from 'meteor/antonly:mcrypt';\r\nimport { Mongo } from 'meteor/mongo';\r\n\r\nlet salt, cleartext, ciphertext, tomsCleartext, annasClearText, clear2, clear3;\r\n\r\n\r\n////// simple form: ///////\r\n\r\n// generate a salt\r\nsalt       = mcrypt.generateSalt();\r\ncleartext  = 'The cake is a lie!';\r\n// userId is not used since the salt is given\r\nciphertext = mcrypt.encrypt(cleartext, 0, salt); \r\n\r\nconsole.log(`Encrypted '${cleartext}' to '${ciphertext}' with salt '${salt}'`);\r\n\r\nclear2     = mcrypt.decrypt(ciphertext, 0, salt);\r\n\r\nconsole.log(`Decrypted '${ciphertext}' to '${clear2}' with salt '${salt}'`);\r\n\r\n\r\n////// a little more advanced: ///////\r\n\r\n// substitution for a user DB\r\nconst persons = {\r\n  'anna': {salt: mcrypt.generateSalt()},\r\n  'tom': {salt: mcrypt.generateSalt()}\r\n}\r\n\r\n// tell the encrypter where he can find the salts\r\nmcrypt.configure({\r\n  getUserSalt(user, context) {\r\n    return persons[user].salt;\r\n  }\r\n})\r\n\r\n// what anna does:\r\ncleartext      = 'I got a cake!';\r\nciphertext     = mcrypt.encrypt(cleartext, 'anna');\r\n      \r\n// anna can now store the ciphertext anywhere she wants\r\n\r\nconsole.log(`Anna encrypted '${cleartext}' to '${ciphertext}'`);\r\n\r\n// what tom tries:\r\ntomsCleartext  = mcrypt.decrypt(ciphertext, 'tom');\r\n\r\nconsole.log(`Tom tried to decrypted '${ciphertext}' to '${tomsCleartext}'`);\r\n\r\n// and what anna decrypts again\r\nannasClearText = mcrypt.decrypt(ciphertext, 'anna');\r\n\r\nconsole.log(`Anna decrypted '${ciphertext}' to '${annasClearText}'`);\r\n\r\n\r\n////// a little more advanced: ///////\r\n\r\n// changing the settings will render all preiously created ciphertext unreadable\r\nmcrypt.configure({\r\n  getSaltLen: 8,\r\n  getAppKey: 'super-secret-app-key',\r\n  getUserSalt(id, context) {\r\n    // search for the salt in the DB provided as context\r\n\r\n    return context.findOne(id).secretFields.salt;\r\n  },\r\n  getUserKeyLen: 8,\r\n  getRounds: 500,\r\n  getDigest: 'sha256',\r\n  getAlgorithm: 'aes192', \r\n  throwDecryptError: false\r\n});\r\n\r\n\r\n////// realistic use: ///////\r\n\r\n// create a real DB\r\nconst Users = new Mongo.Collection('test-users');\r\n\r\n// reset it\r\nUsers.remove({});\r\n\r\n// add two users to it\r\nUsers.insert({\r\n  _id: 'A', \r\n  name: 'Anna', \r\n  secretFields: {\r\n    salt: mcrypt.generateSalt()\r\n  }\r\n});\r\nUsers.insert({\r\n  _id: 'B', \r\n  name: 'Tom', \r\n  secretFields: {\r\n    salt: mcrypt.generateSalt()\r\n  }\r\n});\r\n\r\ncleartext  = 'And all the cake is gone.';\r\n// if the salt is set to false, it will use the userId to get to the salt\r\nciphertext = mcrypt.encrypt(cleartext, 'A', false, Users); // <- Annas ID\r\n\r\nconsole.log(`Anna encrypted '${cleartext}' to '${ciphertext}'`);\r\n\r\nclear2     = mcrypt.decrypt(ciphertext, 'B', false, Users); // <- Toms ID\r\n\r\nconsole.log(`Tom decrypted '${ciphertext}' to '${clear2}'`);\r\n\r\nclear3     = mcrypt.decrypt(ciphertext, 'A', false, Users); // <- Annas ID\r\n\r\nconsole.log(`Anna decrypted '${ciphertext}' to '${clear3}'`);\r\n````\r\n\r\n### Tests\r\nThere are a couple of TinyTest tests. To run them:\r\n\r\n  1. Install TinyTest: `meteor add tinytest`\r\n  2. Run Meteor in test mode with your settings file: `meteor test-packages --settings settings.json`\r\n  3. Navigate to `http://localhost:3000`\r\n  4. Hopefully see all tests passing:\r\n\r\n![http://i.imgur.com/CSaulpQ.png](http://i.imgur.com/CSaulpQ.png)\r\n\r\n### License\r\nThe code for this package is licensed under the [MIT License](http://opensource.org/licenses/MIT).\r\n\r\n   [1]: http://security.stackexchange.com/a/3993\r\n   [2]: https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest\r\n   [3]: https://nodejs.org/api/crypto.html#crypto_class_cipher\r\n   [4]: https://nodejs.org/api/crypto.html\r\n   [5]: https://nodejs.org/api/crypto.html#crypto_class_hash\r\n   [6]: https://themeteorchef.com/snippets/making-use-of-settings-json/\r\n    \r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}